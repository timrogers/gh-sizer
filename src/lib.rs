const VERSION: &str = env!("CARGO_PKG_VERSION");

pub mod enums;
pub use crate::enums::OutputFormat;

pub mod github_repository_lister;
pub use crate::github_repository_lister::GitHubRepositoryLister;

pub mod generate_script {
    use crate::enums::OutputFormat;
    use crate::enums::ScriptType;
    use crate::github_repository_lister::GitHubRepositoryLister;
    use std::io::{Error, Write};
    use std::path::PathBuf;

    #[cfg(test)]
    use crate::github_repository_lister::MockGitHubRepositoryLister;

    fn generate_powershell_script(
        repository_names: Vec<String>,
        owner: &str,
        output_format: OutputFormat,
        output_directory: &str,
        output_filename_template: &str,
        gh_sizer_command: &str,
    ) -> String {
        let mut generated_script: String = format!(
            "#!/usr/bin/env pwsh\n\n# Script generated by gh-sizer v{}\n\n",
            crate::VERSION
        );

        // Update line to create a directory
        let script_line = format!(
            "New-Item -Name {} -ItemType directory -Force | Out-Null\n",
            output_directory
        )
        .to_string();
        generated_script.push_str(&script_line);

        for repository_name in repository_names.iter() {
            let output_filename = output_filename_template
                .replace("${owner}", owner)
                .replace("${repository}", repository_name);
            let output_path = PathBuf::from(output_directory).join(output_filename);
            let script_line = format!(
                "{} repo {}/{} --output-format {} | Out-File -Path {}\n",
                gh_sizer_command,
                owner,
                repository_name,
                output_format,
                output_path.display()
            )
            .to_string();
            generated_script.push_str(&script_line);
        }

        generated_script.push_str(&format!(
            "\n# Script generated by gh-sizer v{}",
            crate::VERSION
        ));

        return generated_script;
    }

    fn generate_bash_script(
        repository_names: Vec<String>,
        owner: &str,
        output_format: OutputFormat,
        output_directory: &str,
        output_filename_template: &str,
        gh_sizer_command: &str,
    ) -> String {
        let mut generated_script: String = format!(
            "#!/usr/bin/env bash\n\n# Script generated by gh-sizer v{}\n\n",
            crate::VERSION
        );

        let script_line = format!("mkdir -p {}\n", output_directory).to_string();
        generated_script.push_str(&script_line);

        for repository_name in repository_names.iter() {
            let output_filename = output_filename_template
                .replace("${owner}", owner)
                .replace("${repository}", repository_name);
            let output_path = PathBuf::from(output_directory).join(output_filename);
            let script_line = format!(
                "{} repo {}/{} --output-format {} > {}\n",
                gh_sizer_command,
                owner,
                repository_name,
                output_format,
                output_path.display()
            )
            .to_string();
            generated_script.push_str(&script_line);
        }

        generated_script.push_str(&format!(
            "\n\n# Script generated by gh-sizer v{}",
            crate::VERSION
        ));

        return generated_script;
    }

    pub fn call(
        owner: &str,
        script_type: ScriptType,
        output_format: OutputFormat,
        output_directory: &str,
        output_filename_template: &str,
        gh_sizer_command: &str,
        github_repository_lister: &impl GitHubRepositoryLister,
        stderr: &mut impl Write,
    ) -> Result<String, Error> {
        let repository_names = github_repository_lister.call(owner)?;

        writeln!(
            stderr,
            "Generating script for {} repositories owned by {}",
            repository_names.len(),
            owner
        )?;

        let generated_script;

        if matches!(script_type, ScriptType::Bash) {
            generated_script = generate_bash_script(
                repository_names,
                owner,
                output_format,
                output_directory,
                output_filename_template,
                gh_sizer_command,
            );
        } else {
            generated_script = generate_powershell_script(
                repository_names,
                owner,
                output_format,
                output_directory,
                output_filename_template,
                gh_sizer_command,
            );
        }

        Ok(generated_script)
    }

    #[test]
    #[cfg(not(windows))]
    fn generate_script_generates_bash_script_with_file_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let bash_script = call(
            "github",
            ScriptType::Bash.to_owned(),
            OutputFormat::Text.to_owned(),
            "output/directory",
            "${owner}-${repository}.txt",
            "gh sizer",
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(bash_script);
    }

    #[test]
    #[cfg(not(windows))]
    fn generate_script_generates_powershell_script_with_file_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let powershell_script = call(
            "github",
            ScriptType::Powershell.to_owned(),
            OutputFormat::Text.to_owned(),
            "output/directory",
            "${owner}-${repository}.txt",
            "gh sizer",
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(powershell_script);
    }

    #[test]
    #[cfg(not(windows))]
    fn generate_script_generates_bash_script_with_json_formatted_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let bash_script = call(
            "github",
            ScriptType::Bash.to_owned(),
            OutputFormat::Json.to_owned(),
            "output/directory",
            "${repository}.txt",
            "gh sizer",
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(bash_script);
    }

    #[test]
    #[cfg(not(windows))]
    fn generate_script_generates_powershell_script_with_json_formatted_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let powershell_script = call(
            "github",
            ScriptType::Powershell.to_owned(),
            OutputFormat::Json.to_owned(),
            "output/directory",
            "${repository}.txt",
            "gh sizer",
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(powershell_script);
    }

    #[test]
    fn generate_script_logs_number_of_repos() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        call(
            "github",
            ScriptType::Bash.to_owned(),
            OutputFormat::Json.to_owned(),
            "output/directory",
            "${repository}.txt",
            "gh sizer",
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        assert_eq!(
            String::from_utf8_lossy(&stderr),
            "Generating script for 1 repositories owned by github\n"
        );
    }
}
