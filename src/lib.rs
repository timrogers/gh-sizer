const VERSION: &str = env!("CARGO_PKG_VERSION");

pub mod github_repository_lister {
    use std::process::Command;
    use std::io::Error;

    #[cfg(test)]
    use mockall::{automock, predicate::*};

    #[cfg_attr(test, automock)]
    pub trait GitHubRepositoryLister {
        fn call(&self, organization: &str, github_token: Option<String>) -> Result<Vec<String>, Error>;
    }

    pub struct GitHubRepositoryListerImpl;

    impl GitHubRepositoryLister for GitHubRepositoryListerImpl {
        fn call(&self, organization: &str, github_token: Option<String>) -> Result<Vec<String>, Error> {
            let mut list_command = Command::new("gh");
            list_command.arg("repo");
            list_command.arg("list");
            list_command.arg(organization);
            list_command.arg("-L");
            list_command.arg("10000");
            list_command.arg("--json");
            list_command.arg("name");
            list_command.arg("--jq");
            list_command.arg(".[].name");

            if github_token.is_some() {
                list_command.env("GITHUB_TOKEN", github_token.unwrap().to_string());
            }

            let list_command_output = list_command.output()?;

            if !list_command_output.status.success() {
                eprintln!("{}", String::from_utf8_lossy(&list_command_output.stderr));
                std::process::exit(exitcode::DATAERR);
            }

            let output_text = String::from_utf8_lossy(&list_command_output.stdout);
            let output_lines: Vec<String> = output_text
                .split_whitespace()
                .map(|s| s.to_string())
                .collect();

            Ok(output_lines)
        }
    }
}

pub mod enums {
    use std::fmt;

    #[derive(clap::ValueEnum, Clone, Debug)]
    pub enum Output {
        Stdout,
        File,
    }

    impl fmt::Display for Output {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                Output::Stdout => write!(f, "stdout"),
                Output::File => write!(f, "file"),
            }
        }
    }

    #[derive(clap::ValueEnum, Clone, Debug)]
    pub enum OutputFormat {
        Text,
        Json,
    }

    impl fmt::Display for OutputFormat {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                OutputFormat::Text => write!(f, "text"),
                OutputFormat::Json => write!(f, "json"),
            }
        }
    }
}

pub mod generate_script {
    use std::io::{Error, Write};
    use std::path::PathBuf;
    use crate::github_repository_lister::GitHubRepositoryLister;
    use crate::enums::Output;
    use crate::enums::OutputFormat;

    #[cfg(test)]
    use crate::github_repository_lister::MockGitHubRepositoryLister;

    pub fn call(
        organization: &str,
        output: Output,
        output_format: OutputFormat,
        output_directory: &str,
        output_filename_template: &str,
        gh_sizer_command: &str,
        github_token: Option<String>,
        github_repository_lister: &impl GitHubRepositoryLister,
        stderr: &mut impl Write,
    ) -> Result<String, Error> {
        let repository_names = github_repository_lister.call(organization, github_token)?;
    
        writeln!(
            stderr,
            "Generating script for {} repositories in organization {}",
            repository_names.len(),
            organization
        )?;
    
        let mut generated_script: String = format!(
            "#!/usr/bin/env bash\n\n# Script generated by gh-sizer v{}\n\n",
            crate::VERSION
        );
    
        if matches!(output, crate::enums::Output::File) {
            let script_line = format!("mkdir -p {}\n", output_directory).to_string();
            generated_script.push_str(&script_line)
        }
    
        for repository_name in repository_names.iter() {
            if matches!(output, crate::enums::Output::Stdout) {
                let script_line = format!(
                    "OUTPUT=$(gh sizer repo {}/{} --output-format {})\necho $OUTPUT\n\n",
                    organization, repository_name, output_format
                )
                .to_string();
                generated_script.push_str(&script_line);
            } else {
                let output_filename = output_filename_template
                    .replace("${organization}", organization)
                    .replace("${repository}", repository_name);
                let output_path = PathBuf::from(output_directory).join(output_filename);
                let script_line = format!(
                    "{} repo {} --output-format {} > {}\n",
                    gh_sizer_command,
                    repository_name,
                    output_format,
                    output_path.display()
                )
                .to_string();
                generated_script.push_str(&script_line);
            }
        }
    
        generated_script.push_str(&format!("\n\n# Script generated by gh-sizer v{}", crate::VERSION));
    
        Ok(generated_script)
    }

    #[test]
fn generate_script_generates_bash_script_with_stdout_output() {
    let mut lister_mock = MockGitHubRepositoryLister::new();

    lister_mock
        .expect_call()
        .returning(|_, _| Ok(vec!["github/gh-sizer".to_string()]));

    let mut stderr = Vec::new();

    let bash_script = call(
        "github",
        Output::Stdout.to_owned(),
        OutputFormat::Text.to_owned(),
        "",
        "",
        "gh sizer",
        None,
        &lister_mock,
        &mut stderr,
    )
    .unwrap();

    insta::assert_yaml_snapshot!(bash_script);
}

#[test]
fn generate_script_generates_bash_script_with_file_output() {
    let mut lister_mock = MockGitHubRepositoryLister::new();

    lister_mock
        .expect_call()
        .returning(|_, _| Ok(vec!["gh-sizer".to_string()]));

    let mut stderr = Vec::new();

    let bash_script = call(
        "github",
        Output::File.to_owned(),
        OutputFormat::Text.to_owned(),
        "output/directory",
        "${repository}.txt",
        "gh sizer",
        None,
        &lister_mock,
        &mut stderr,
    )
    .unwrap();

    insta::assert_yaml_snapshot!(bash_script);
}

#[test]
fn generate_script_generates_bash_script_with_json_formatted_output() {
    let mut lister_mock = MockGitHubRepositoryLister::new();

    lister_mock
        .expect_call()
        .returning(|_, _| Ok(vec!["gh-sizer".to_string()]));

    let mut stderr = Vec::new();

    let bash_script = call(
        "github",
        Output::File.to_owned(),
        OutputFormat::Json.to_owned(),
        "output/directory",
        "${repository}.txt",
        "gh sizer",
        None,
        &lister_mock,
        &mut stderr,
    )
    .unwrap();

    insta::assert_yaml_snapshot!(bash_script);
}

#[test]
fn generate_script_logs_number_of_repos() {
    let mut lister_mock = MockGitHubRepositoryLister::new();

    lister_mock
        .expect_call()
        .returning(|_, _| Ok(vec!["gh-sizer".to_string()]));

    let mut stderr = Vec::new();

    call(
        "github",
        Output::File.to_owned(),
        OutputFormat::Json.to_owned(),
        "output/directory",
        "${repository}.txt",
        "gh sizer",
        None,
        &lister_mock,
        &mut stderr,
    )
    .unwrap();

    assert_eq!(
        String::from_utf8_lossy(&stderr),
        "Generating script for 1 repositories in organization github\n"
    );
}

}