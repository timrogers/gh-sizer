const VERSION: &str = env!("CARGO_PKG_VERSION");

pub mod enums;
pub use crate::enums::Output;
pub use crate::enums::OutputFormat;

pub mod github_repository_lister;
pub use crate::github_repository_lister::GitHubRepositoryLister;

pub mod generate_script {
    use crate::enums::Output;
    use crate::enums::OutputFormat;
    use crate::github_repository_lister::GitHubRepositoryLister;
    use std::io::{Error, Write};
    use std::path::PathBuf;

    #[cfg(test)]
    use crate::github_repository_lister::MockGitHubRepositoryLister;

    pub fn call(
        organization: &str,
        output: Output,
        output_format: OutputFormat,
        output_directory: &str,
        output_filename_template: &str,
        gh_sizer_command: &str,
        github_token: Option<String>,
        github_repository_lister: &impl GitHubRepositoryLister,
        stderr: &mut impl Write,
    ) -> Result<String, Error> {
        let repository_names = github_repository_lister.call(organization, github_token)?;

        writeln!(
            stderr,
            "Generating script for {} repositories in organization {}",
            repository_names.len(),
            organization
        )?;

        let mut generated_script: String = format!(
            "#!/usr/bin/env bash\n\n# Script generated by gh-sizer v{}\n\n",
            crate::VERSION
        );

        if matches!(output, crate::enums::Output::File) {
            let script_line = format!("mkdir -p {}\n", output_directory).to_string();
            generated_script.push_str(&script_line)
        }

        for repository_name in repository_names.iter() {
            if matches!(output, crate::enums::Output::Stdout) {
                let script_line = format!(
                    "OUTPUT=$(gh sizer repo {}/{} --output-format {})\necho $OUTPUT\n\n",
                    organization, repository_name, output_format
                )
                .to_string();
                generated_script.push_str(&script_line);
            } else {
                let output_filename = output_filename_template
                    .replace("${organization}", organization)
                    .replace("${repository}", repository_name);
                let output_path = PathBuf::from(output_directory).join(output_filename);
                let script_line = format!(
                    "{} repo {} --output-format {} > {}\n",
                    gh_sizer_command,
                    repository_name,
                    output_format,
                    output_path.display()
                )
                .to_string();
                generated_script.push_str(&script_line);
            }
        }

        generated_script.push_str(&format!(
            "\n\n# Script generated by gh-sizer v{}",
            crate::VERSION
        ));

        Ok(generated_script)
    }

    #[test]
    fn generate_script_generates_bash_script_with_stdout_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_, _| Ok(vec!["github/gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let bash_script = call(
            "github",
            Output::Stdout,
            OutputFormat::Text.to_owned(),
            "",
            "",
            "gh sizer",
            None,
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(bash_script);
    }

    #[test]
    fn generate_script_generates_bash_script_with_file_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_, _| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let bash_script = call(
            "github",
            Output::File,
            OutputFormat::Text.to_owned(),
            "output/directory",
            "${repository}.txt",
            "gh sizer",
            None,
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(bash_script);
    }

    #[test]
    fn generate_script_generates_bash_script_with_json_formatted_output() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_, _| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        let bash_script = call(
            "github",
            Output::File,
            OutputFormat::Json.to_owned(),
            "output/directory",
            "${repository}.txt",
            "gh sizer",
            None,
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        insta::assert_yaml_snapshot!(bash_script);
    }

    #[test]
    fn generate_script_logs_number_of_repos() {
        let mut lister_mock = MockGitHubRepositoryLister::new();

        lister_mock
            .expect_call()
            .returning(|_, _| Ok(vec!["gh-sizer".to_string()]));

        let mut stderr = Vec::new();

        call(
            "github",
            Output::File,
            OutputFormat::Json.to_owned(),
            "output/directory",
            "${repository}.txt",
            "gh sizer",
            None,
            &lister_mock,
            &mut stderr,
        )
        .unwrap();

        assert_eq!(
            String::from_utf8_lossy(&stderr),
            "Generating script for 1 repositories in organization github\n"
        );
    }
}
